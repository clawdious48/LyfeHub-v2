---
phase: 03-tab-shell-log-initialization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/dryingLogs.js
  - backend/src/routes/drying.js
  - frontend/js/jobDetailTabs.js
autonomous: true

must_haves:
  truths:
    - "Drying Logs tab appears for any Apex job (no MIT-only restriction)"
    - "When no drying log exists, tab shows a Create Drying Logs button"
    - "Clicking Create Drying Logs creates a log with rooms pre-populated from areas_affected"
    - "After creation, the tab shows a room list with the pre-populated room names"
    - "If areas_affected is empty, log is created with a default chamber and zero rooms"
  artifacts:
    - path: "backend/src/db/dryingLogs.js"
      provides: "createDryingLogWithRooms transaction function"
      contains: "createDryingLogWithRooms"
    - path: "backend/src/routes/drying.js"
      provides: "Extended POST /log with room pre-population"
      contains: "areas_affected"
    - path: "frontend/js/jobDetailTabs.js"
      provides: "Dynamic drying tab with async loading and create button"
      contains: "_loadDryingState"
  key_links:
    - from: "frontend/js/jobDetailTabs.js"
      to: "api.getDryingLog"
      via: "_loadDryingState async fetch"
      pattern: "api\\.getDryingLog"
    - from: "frontend/js/jobDetailTabs.js"
      to: "api.createDryingLog"
      via: "_createDryingLog click handler"
      pattern: "api\\.createDryingLog"
    - from: "backend/src/routes/drying.js"
      to: "dryingLogs.createDryingLogWithRooms"
      via: "POST /log route calling transaction"
      pattern: "createDryingLogWithRooms"
---

<objective>
Replace the static placeholder Drying tab with a functional tab that checks for an existing drying log, shows a "Create Drying Logs" button when none exists, and creates a log with rooms pre-populated from the job's areas_affected field.

Purpose: This is the entry point for all drying log functionality. Without this, technicians have no way to start the drying documentation process.
Output: Backend transaction for atomic log+chamber+room creation, extended POST /log route, and a dynamic frontend tab that loads drying state and handles creation.
</objective>

<execution_context>
@C:/Users/jaker/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-tab-shell-log-initialization/03-RESEARCH.md
@backend/src/db/dryingLogs.js
@backend/src/routes/drying.js
@frontend/js/jobDetailTabs.js
@frontend/js/api.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add createDryingLogWithRooms transaction and extend POST /log route</name>
  <files>backend/src/db/dryingLogs.js, backend/src/routes/drying.js</files>
  <action>
**In `backend/src/db/dryingLogs.js`:**

Add a new exported transaction function `createDryingLogWithRooms` that atomically creates a drying log, a default chamber, and pre-populated rooms. Place it after the existing `createDryingLog` function (around line 164):

```javascript
const createDryingLogWithRooms = db.transaction((jobId, roomNames) => {
  const logId = uuidv4();
  insertLog.run(logId, jobId, 'active', 1);

  // Always create a default chamber (rooms require a parent chamber_id)
  const chamberId = uuidv4();
  insertChamber.run(chamberId, logId, 'Default', '', 0);

  const rooms = [];
  roomNames.forEach((name, i) => {
    const roomId = uuidv4();
    insertRoom.run(roomId, chamberId, name, i);
    rooms.push({ id: roomId, chamber_id: chamberId, name, position: i });
  });

  const log = getLogByJobId.get(jobId);
  return {
    log,
    chambers: [{ id: chamberId, log_id: logId, name: 'Default', color: '', position: 0 }],
    rooms
  };
});
```

Add `createDryingLogWithRooms` to the module.exports object alongside the existing `createDryingLog`.

**In `backend/src/routes/drying.js`:**

Modify the existing `POST /log` route handler (lines 77-89) to:
1. After the 409 check, read the job's `areas_affected` field using `db.prepare('SELECT areas_affected FROM apex_jobs WHERE id = ?').get(req.params.id)`
2. Parse the areas_affected text with: `text.split(/[,;\n]+/).map(s => s.trim()).filter(Boolean)` -- this handles commas, semicolons, and newlines. If `areas_affected` is empty/null, result is an empty array.
3. Call `dryingLogs.createDryingLogWithRooms(req.params.id, roomNames)` instead of `dryingLogs.createDryingLog(req.params.id)`
4. Return 201 with the composite `{ log, chambers, rooms }` response

The prepared statement for reading `areas_affected` can be defined at module scope (above the routes) for efficiency, or inline since it's called rarely (at log creation only). Inline is fine given the infrequent use.

Do NOT modify the existing `createDryingLog` function -- keep it as-is for backward compatibility. The new `createDryingLogWithRooms` is an alternative that adds room pre-population.
  </action>
  <verify>
Start the backend with `cd backend && npm run dev` (or Docker). Then use curl to test:

1. `curl -X POST http://localhost:3000/api/apex-jobs/{JOBID}/drying/log -H "Cookie: ..."` -- should return 201 with `{ log, chambers, rooms }` where rooms match the job's areas_affected parsed values
2. Calling POST again should return 409 with the existing log
3. For a job with empty areas_affected, POST should return 201 with `{ log, chambers: [{name: 'Default', ...}], rooms: [] }`

If no running server is available, verify by reading the code and confirming the transaction, parsing logic, and response structure are correct.
  </verify>
  <done>
POST /log creates a drying log with a default chamber and rooms parsed from areas_affected in a single atomic transaction. Response includes { log, chambers, rooms }. Empty areas_affected produces a log with a default chamber and zero rooms. Existing createDryingLog function is preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace renderDryingTab placeholder with async-loading dynamic tab</name>
  <files>frontend/js/jobDetailTabs.js</files>
  <action>
Replace the entire `renderDryingTab` method (lines 477-509) in the `jobDetailTabs` object with the following implementation. The replacement must cover all the code from `renderDryingTab(job) {` through its closing `}` before the `};` that closes the jobDetailTabs object.

**New `renderDryingTab` method:**
```javascript
renderDryingTab(job) {
    // Render a loading placeholder, then async-load the real state
    setTimeout(() => jobDetailTabs._loadDryingState(job.id), 0);

    return `
        <div class="apex-modal-section" id="drying-tab-content">
            <h3 class="apex-section-title">Structural Drying</h3>
            <div class="apex-empty-state">Loading drying log status...</div>
        </div>
    `;
},
```

**Add the following helper methods** inside the `jobDetailTabs` object, after the `renderDryingTab` method and before the closing `};`:

1. **`_loadDryingState(jobId)`** -- Async method that:
   - First checks `apexJobs.activeTab !== 'drying'` and returns early if tab changed (race condition guard per research pitfall 1)
   - Gets the container via `document.getElementById('drying-tab-content')`
   - Calls `api.getDryingLog(jobId)` in a try/catch
   - On success: checks `apexJobs.activeTab` again, then sets `container.innerHTML` to `_renderDryingLogView(log, jobId)`, then calls `_loadDryingRooms(jobId)` to populate the rooms list
   - On 404 error (check `err.message` includes '404' or err.status === 404 or the response text includes 'No drying log'): checks activeTab again, then sets `container.innerHTML` to `_renderCreateDryingButton(jobId)`
   - On other error: shows a generic "Failed to load drying log" empty state

2. **`_renderCreateDryingButton(jobId)`** -- Returns HTML string:
   ```html
   <h3 class="apex-section-title">Structural Drying</h3>
   <div class="apex-empty-state">
       <p>No drying log exists for this job.</p>
       <button class="jdt-add-btn" id="create-drying-btn"
           onclick="jobDetailTabs._createDryingLog('${jobId}')">
           Create Drying Logs
       </button>
   </div>
   ```

3. **`_createDryingLog(jobId)`** -- Async method that:
   - Immediately disables the button: `const btn = document.getElementById('create-drying-btn'); if (btn) { btn.disabled = true; btn.textContent = 'Creating...'; }`
   - Calls `api.createDryingLog(jobId)` in a try/catch
   - On success (201) or on 409 (log already exists -- treat as success per research recommendation): re-render by calling `_loadDryingState(jobId)` to show the room list
   - On 409 specifically: the API may throw -- catch it, and if the error response contains a `log` property, proceed to _loadDryingState
   - On other error: re-enable the button, show console.error

4. **`_renderDryingLogView(log, jobId)`** -- Returns HTML string showing the log status and a rooms section:
   ```html
   <h3 class="apex-section-title">Structural Drying</h3>
   <div style="margin-bottom: 12px;">
       <span class="apex-status-badge phase-status-${log.status === 'active' ? 'in_progress' : 'complete'}">${log.status === 'active' ? 'Active' : 'Complete'}</span>
   </div>
   <div class="apex-phase-section">
       <h4 class="apex-phase-section-title">Rooms</h4>
       <div id="drying-rooms-list"><div class="apex-empty-state">Loading rooms...</div></div>
       <button class="jdt-add-btn" onclick="jobDetailTabs._addRoom('${jobId}')">+ Add Room</button>
   </div>
   ```

5. **`_loadDryingRooms(jobId)`** -- Async method that:
   - Gets `document.getElementById('drying-rooms-list')`, returns if missing
   - Calls `api.getDryingRooms(jobId)` to get all rooms
   - If `apexJobs.activeTab !== 'drying'` return early
   - If rooms is empty, shows "No rooms yet. Add rooms to get started."
   - Otherwise renders each room as a row with the room name, a rename button (pencil icon or text "Rename"), and a delete button (x icon). Use `data-room-id` attributes for wiring. Each room row:
     ```html
     <div class="jdt-expense-row" data-room-id="${room.id}" style="justify-content: space-between; padding: 8px 12px;">
         <span class="drying-room-name">${apexJobs.escapeHtml(room.name)}</span>
         <span>
             <button class="jdt-note-delete" onclick="jobDetailTabs._renameRoom('${jobId}', '${room.id}', this)" title="Rename" style="margin-right:8px;">&#9998;</button>
             <button class="jdt-note-delete" onclick="jobDetailTabs._deleteRoom('${jobId}', '${room.id}')" title="Delete">&times;</button>
         </span>
     </div>
     ```

6. **`_addRoom(jobId)`** -- Async method that:
   - Prompts for a room name: `const name = prompt('Enter room name:'); if (!name || !name.trim()) return;`
   - Needs the chamber_id. Fetch chambers: `const chambers = await api.getDryingChambers(jobId); if (!chambers.length) return;`
   - Calls `api.createDryingRoom(jobId, { chamber_id: chambers[0].id, name: name.trim() })`
   - Calls `_loadDryingRooms(jobId)` to refresh the list

7. **`_renameRoom(jobId, roomId, btnEl)`** -- Async method that:
   - Gets current name from the row: `const row = btnEl.closest('[data-room-id]'); const nameEl = row.querySelector('.drying-room-name'); const current = nameEl.textContent;`
   - Prompts: `const newName = prompt('Rename room:', current); if (!newName || !newName.trim() || newName.trim() === current) return;`
   - Calls `api.updateDryingRoom(jobId, roomId, { name: newName.trim() })`
   - Updates the name element in-place: `nameEl.textContent = newName.trim();`

8. **`_deleteRoom(jobId, roomId)`** -- Async method that:
   - Confirms: `if (!confirm('Delete this room?')) return;`
   - Calls `api.deleteDryingRoom(jobId, roomId)`
   - Calls `_loadDryingRooms(jobId)` to refresh the list

**Important notes:**
- The `renderDryingTab` signature changes from `renderDryingTab(job)` to `renderDryingTab(job)` (same, but the existing `phaseId` param in the dispatch call on line 520 is not used -- the method signature only takes `job`, matching the existing pattern).
- The `renderTab` dispatch on line 520 passes `(job, phaseId)` but the current `renderDryingTab` only accepts `(job)`. This is fine -- JS ignores extra arguments.
- All new methods start with underscore prefix following the existing convention (_submitNote, _deleteNote, _toggleSection, etc.).
- Use `apexJobs.escapeHtml` for HTML escaping (same as other tabs).
- The `api.getDryingLog` call returns the log object on 200 or throws on 404. Check the error handling in `api.request()` to determine how 404s are surfaced -- if `api.request` throws an error with the response status, catch accordingly.
  </action>
  <verify>
1. Read the modified `jobDetailTabs.js` and verify:
   - renderDryingTab returns a loading state with `id="drying-tab-content"`
   - _loadDryingState checks activeTab guard before DOM updates
   - _createDryingLog disables button on click, handles 409 gracefully
   - _renderDryingLogView includes rooms list container with id="drying-rooms-list"
   - _loadDryingRooms fetches and renders room rows with rename/delete buttons
   - _addRoom uses prompt and api.createDryingRoom
   - _renameRoom uses prompt and api.updateDryingRoom
   - _deleteRoom uses confirm and api.deleteDryingRoom
2. Verify the old MIT-only restriction (`isMit` check) is removed
3. Verify the old placeholder HTML (equipment tracking, daily readings, moisture levels sections) is removed
  </verify>
  <done>
The drying tab is fully dynamic: it async-loads drying log state on tab activation, shows a "Create Drying Logs" button when no log exists, and shows a room list with rename/delete/add controls when a log exists. The MIT-only restriction is removed. Race condition guards prevent stale tab content. Button double-click is prevented via disable-on-click.
  </done>
</task>

</tasks>

<verification>
After both tasks are complete:
1. The Drying Logs tab should load for any Apex job (not MIT-only)
2. If no drying log exists, the tab shows "No drying log exists for this job." with a "Create Drying Logs" button
3. Clicking the button creates a log with rooms pre-populated from the job's areas_affected field
4. After creation, rooms are displayed with rename, delete, and add controls
5. The button is disabled while creating (prevents double-click)
6. Tab switching during async load does not cause content flicker (activeTab guard)
7. A 409 response (log already exists) is handled gracefully as success
</verification>

<success_criteria>
- POST /api/apex-jobs/:id/drying/log returns { log, chambers, rooms } with pre-populated rooms from areas_affected
- renderDryingTab shows loading state, then async-loads create button or room list
- Room CRUD (add, rename, delete) works via existing API client methods
- No MIT-only restriction on the drying tab
</success_criteria>

<output>
After completion, create `.planning/phases/03-tab-shell-log-initialization/03-01-SUMMARY.md`
</output>
