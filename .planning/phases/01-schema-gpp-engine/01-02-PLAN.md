---
phase: 01-schema-gpp-engine
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/src/db/dryingLogs.js
autonomous: true

must_haves:
  truths:
    - "calculateGPP(75, 60) returns 77.8 (and all 15 validation pairs match within +/- 0.1)"
    - "calculateGPP uses sea level pressure 14.696 psia by default"
    - "calculateGPP returns null for invalid inputs (null, NaN, RH out of range)"
    - "meetsDryStandard(15, 11) returns true (15 <= 11 + 4) and meetsDryStandard(16, 11) returns false"
    - "Saving a moisture reading auto-computes meets_dry_standard from baseline lookup"
    - "Adding a reference point atomically increments next_ref_number within a transaction"
  artifacts:
    - path: "backend/src/db/dryingLogs.js"
      provides: "GPP calculation, dry-standard comparison, CRUD functions, prepared statements"
      exports: ["calculateGPP", "meetsDryStandard"]
      min_lines: 100
  key_links:
    - from: "backend/src/db/dryingLogs.js"
      to: "backend/src/db/schema.js"
      via: "require('./schema') for db instance"
      pattern: "require\\('./schema'\\)"
    - from: "calculateGPP"
      to: "drying_atmospheric_readings.gpp"
      via: "computed on insert and stored in row"
      pattern: "calculateGPP.*temp_f.*rh_percent"
    - from: "meetsDryStandard"
      to: "drying_moisture_readings.meets_dry_standard"
      via: "computed on insert using baseline lookup"
      pattern: "readingValue\\s*<=\\s*baselineValue\\s*\\+\\s*4"
---

<objective>
Create the GPP calculation engine, dry-standard comparison logic, and core CRUD functions for drying log data.

Purpose: Provide the server-side computation layer that Phase 2 (API routes) will call. GPP must be calculated authoritatively on write. Dry-standard comparison must be computed on write. Reference point numbering must be atomic.

Output: `backend/src/db/dryingLogs.js` (new file) with exported functions.
</objective>

<execution_context>
@C:/Users/jaker/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-schema-gpp-engine/01-RESEARCH.md
@.planning/phases/01-schema-gpp-engine/01-01-SUMMARY.md

@backend/src/db/schema.js
@backend/src/db/apexJobs.js
@backend/src/db/dryingSchema.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GPP calculation and dry-standard comparison functions</name>
  <files>backend/src/db/dryingLogs.js</files>
  <action>
Create `backend/src/db/dryingLogs.js` with the following structure:

```javascript
const db = require('./schema');
const { v4: uuidv4 } = require('uuid');
```

**1. calculateGPP(tempF, rhPercent, pressurePsia = 14.696)**

Pure function implementing the IAPWS saturation vapor pressure formula. Use EXACTLY these constants (copy precisely -- digit errors cause GPP drift):
- c8 = -10440.397
- c9 = -11.29465
- c10 = -0.027022355
- c11 = 0.00001289036
- c12 = -0.0000000024780681
- c13 = 6.5459673

Steps:
1. Validate inputs: return null if tempF or rhPercent is null/NaN, or if rhPercent < 0 or > 100
2. Convert to Rankine: `const tempR = tempF + 459.67;`
3. Calculate ln(Pws): `c8/tempR + c9 + c10*tempR + c11*tempR^2 + c12*tempR^3 + c13*ln(tempR)`
4. Saturation vapor pressure: `Pws = exp(lnPws)`
5. Actual vapor pressure: `Pw = (rhPercent / 100) * Pws`
6. Humidity ratio: `W = 0.62198 * Pw / (pressurePsia - Pw)`
7. GPP: `W * 7000`
8. Round to 1 decimal: `Math.round(gpp * 10) / 10`

**2. meetsDryStandard(readingValue, baselineValue)**

Returns boolean. A reading meets dry standard when `readingValue <= baselineValue + 4`. Return false if either input is null/undefined.

CRITICAL: Use `<=` (less than or equal), NOT `<`. A reading of exactly baseline + 4 IS dry per IICRC S500.

Both functions must be exported for use by API routes (Phase 2) and potentially client-side (future).
  </action>
  <verify>
Run the 15-pair GPP validation:
```bash
cd backend && node -e "
const { calculateGPP, meetsDryStandard } = require('./src/db/dryingLogs');
const pairs = [
  { tempF: 60, rh: 20, expected: 15.2 },
  { tempF: 60, rh: 50, expected: 38.3 },
  { tempF: 65, rh: 50, expected: 45.8 },
  { tempF: 70, rh: 30, expected: 32.5 },
  { tempF: 70, rh: 50, expected: 54.5 },
  { tempF: 70, rh: 80, expected: 87.8 },
  { tempF: 75, rh: 40, expected: 51.6 },
  { tempF: 75, rh: 50, expected: 64.7 },
  { tempF: 75, rh: 60, expected: 77.8 },
  { tempF: 80, rh: 50, expected: 76.5 },
  { tempF: 80, rh: 60, expected: 92.1 },
  { tempF: 85, rh: 50, expected: 90.2 },
  { tempF: 90, rh: 40, expected: 84.4 },
  { tempF: 90, rh: 80, expected: 172.2 },
  { tempF: 100, rh: 50, expected: 145.5 },
];
let pass = 0;
for (const p of pairs) {
  const got = calculateGPP(p.tempF, p.rh);
  const ok = Math.abs(got - p.expected) <= 0.1;
  if (!ok) console.log('FAIL:', p.tempF, p.rh, 'expected', p.expected, 'got', got);
  else pass++;
}
console.log('GPP validation:', pass + '/15 passed');

// Edge cases
console.log('null temp:', calculateGPP(null, 50));
console.log('NaN rh:', calculateGPP(70, NaN));
console.log('rh > 100:', calculateGPP(70, 101));
console.log('rh < 0:', calculateGPP(70, -1));

// Dry standard
console.log('Dry (15 <= 11+4):', meetsDryStandard(15, 11));
console.log('Not dry (16 > 11+4):', meetsDryStandard(16, 11));
console.log('Null baseline:', meetsDryStandard(10, null));
"
```
Expected: 15/15 GPP pairs pass, edge cases return null, dry standard returns true/false/false correctly.
  </verify>
  <done>calculateGPP matches all 15 IICRC reference pairs within +/- 0.1 GPP. meetsDryStandard uses <= comparison. Both handle null/invalid inputs gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: Implement core CRUD functions with prepared statements</name>
  <files>backend/src/db/dryingLogs.js</files>
  <action>
Add prepared statements at module scope and CRUD functions to `backend/src/db/dryingLogs.js`. Follow the patterns from `apexJobs.js` (prepared statements at module scope, named export functions).

**Prepared statements (module scope):**

```javascript
// Logs
const getLogByJobId = db.prepare('SELECT * FROM drying_logs WHERE job_id = ?');
const insertLog = db.prepare('INSERT INTO drying_logs (id, job_id, status, next_ref_number) VALUES (?, ?, ?, ?)');
const updateLogStatus = db.prepare('UPDATE drying_logs SET status = ?, completed_at = ?, updated_at = datetime(\'now\') WHERE id = ?');
const getNextRefNumber = db.prepare('SELECT next_ref_number FROM drying_logs WHERE id = ?');
const incrementRefNumber = db.prepare('UPDATE drying_logs SET next_ref_number = next_ref_number + 1, updated_at = datetime(\'now\') WHERE id = ?');

// Chambers
const getChambersByLogId = db.prepare('SELECT * FROM drying_chambers WHERE log_id = ? ORDER BY position');
const insertChamber = db.prepare('INSERT INTO drying_chambers (id, log_id, name, color, position) VALUES (?, ?, ?, ?, ?)');

// Rooms
const getRoomsByChamber = db.prepare('SELECT * FROM drying_rooms WHERE chamber_id = ? ORDER BY position');
const insertRoom = db.prepare('INSERT INTO drying_rooms (id, chamber_id, name, position) VALUES (?, ?, ?, ?)');

// Reference points
const getRefPointsByRoom = db.prepare('SELECT * FROM drying_ref_points WHERE room_id = ? ORDER BY ref_number');
const getRefPointsByLog = db.prepare('SELECT * FROM drying_ref_points WHERE log_id = ? ORDER BY ref_number');
const insertRefPoint = db.prepare('INSERT INTO drying_ref_points (id, room_id, log_id, ref_number, material_code, label) VALUES (?, ?, ?, ?, ?, ?)');
const demolishRefPoint = db.prepare('UPDATE drying_ref_points SET demolished_at = datetime(\'now\'), demolished_visit_id = ? WHERE id = ?');

// Baselines
const getBaselinesByLog = db.prepare('SELECT * FROM drying_baselines WHERE log_id = ?');
const getBaselineByMaterial = db.prepare('SELECT * FROM drying_baselines WHERE log_id = ? AND material_code = ?');
const upsertBaseline = db.prepare('INSERT INTO drying_baselines (id, log_id, material_code, baseline_value) VALUES (?, ?, ?, ?) ON CONFLICT(log_id, material_code) DO UPDATE SET baseline_value = excluded.baseline_value, updated_at = datetime(\'now\')');

// Visits
const getVisitsByLog = db.prepare('SELECT * FROM drying_visits WHERE log_id = ? ORDER BY visit_number');
const getVisitById = db.prepare('SELECT * FROM drying_visits WHERE id = ?');
const insertVisit = db.prepare('INSERT INTO drying_visits (id, log_id, visit_number, visited_at) VALUES (?, ?, ?, ?)');

// Atmospheric readings
const getAtmosphericByVisit = db.prepare('SELECT * FROM drying_atmospheric_readings WHERE visit_id = ?');
const insertAtmospheric = db.prepare('INSERT INTO drying_atmospheric_readings (id, visit_id, reading_type, chamber_id, dehu_number, temp_f, rh_percent, gpp) VALUES (?, ?, ?, ?, ?, ?, ?, ?)');
const deleteAtmosphericByVisit = db.prepare('DELETE FROM drying_atmospheric_readings WHERE visit_id = ?');

// Moisture readings
const getMoistureByVisit = db.prepare('SELECT * FROM drying_moisture_readings WHERE visit_id = ?');
const insertMoisture = db.prepare('INSERT INTO drying_moisture_readings (id, visit_id, ref_point_id, reading_value, meets_dry_standard) VALUES (?, ?, ?, ?, ?)');
const deleteMoistureByVisit = db.prepare('DELETE FROM drying_moisture_readings WHERE visit_id = ?');

// Equipment
const getEquipmentByVisit = db.prepare('SELECT * FROM drying_equipment WHERE visit_id = ?');
const insertEquipment = db.prepare('INSERT INTO drying_equipment (id, visit_id, room_id, equipment_type, quantity) VALUES (?, ?, ?, ?, ?)');
const deleteEquipmentByVisit = db.prepare('DELETE FROM drying_equipment WHERE visit_id = ?');

// Visit notes
const getNotesByVisit = db.prepare('SELECT * FROM drying_visit_notes WHERE visit_id = ?');
const insertNote = db.prepare('INSERT INTO drying_visit_notes (id, visit_id, content, photos) VALUES (?, ?, ?, ?)');
```

**Transaction functions:**

**createDryingLog(jobId):** Insert a new drying_log with status='active', next_ref_number=1. Return the created log object.

**addRefPoint(logId, roomId, materialCode, label):** Transaction that:
1. Reads next_ref_number from drying_logs
2. Inserts a drying_ref_point with that number
3. Increments next_ref_number on the log
4. Returns the created ref point with its assigned ref_number

**saveAtmosphericReadings(visitId, readings):** Transaction that:
1. Deletes existing atmospheric readings for the visit (bulk upsert pattern)
2. For each reading: calculate GPP using calculateGPP(reading.tempF, reading.rhPercent), then insert with computed GPP
3. Each reading object has: { readingType, chamberId, dehuNumber, tempF, rhPercent }

**saveMoistureReadings(visitId, readings, logId):** Transaction that:
1. Deletes existing moisture readings for the visit
2. For each reading: look up baseline for the ref point's material_code, compute meetsDryStandard, then insert
3. Each reading object has: { refPointId, readingValue }
4. The function must join through drying_ref_points to get material_code, then look up drying_baselines for that log_id + material_code

**saveEquipment(visitId, equipmentList):** Transaction that:
1. Deletes existing equipment for the visit
2. For each item: insert with { roomId, equipmentType, quantity }

**module.exports:** Export all CRUD functions AND the pure calculation functions:
```javascript
module.exports = {
  calculateGPP,
  meetsDryStandard,
  createDryingLog,
  getLogByJobId: (jobId) => getLogByJobId.get(jobId),
  addRefPoint,
  saveAtmosphericReadings,
  saveMoistureReadings,
  saveEquipment,
  // ... all other getters wrapped as functions
};
```

Wrap prepared statement getters as functions in the export (e.g., `getChambersByLogId: (logId) => getChambersByLogId.all(logId)`) since callers expect functions, not statement objects.
  </action>
  <verify>
Run a full integration test:
```bash
cd backend && node -e "
const dryingLogs = require('./src/db/dryingLogs');
const db = require('./src/db/schema');
const { v4: uuidv4 } = require('uuid');

// Setup: create a test job
const jobId = uuidv4();
db.prepare('INSERT INTO apex_jobs (id, user_id, name, client_name) VALUES (?, ?, ?, ?)').run(jobId, 'test', 'Test Job', 'Test');

// 1. Create drying log
const log = dryingLogs.createDryingLog(jobId);
console.log('Log created:', log.id ? 'PASS' : 'FAIL');

// 2. Create chamber + room
const chamberId = uuidv4();
db.prepare('INSERT INTO drying_chambers (id, log_id, name, color, position) VALUES (?, ?, ?, ?, ?)').run(chamberId, log.id, 'Chamber 1', '#ff0000', 0);
const roomId = uuidv4();
db.prepare('INSERT INTO drying_rooms (id, chamber_id, name, position) VALUES (?, ?, ?, ?)').run(roomId, chamberId, 'Kitchen', 0);

// 3. Add ref point (atomic numbering)
const rp1 = dryingLogs.addRefPoint(log.id, roomId, 'D', 'Kitchen floor');
const rp2 = dryingLogs.addRefPoint(log.id, roomId, 'CW', 'Kitchen wall');
console.log('RP numbering:', rp1.ref_number === 1 && rp2.ref_number === 2 ? 'PASS' : 'FAIL', rp1.ref_number, rp2.ref_number);

// 4. Set baseline
db.prepare('INSERT INTO drying_baselines (id, log_id, material_code, baseline_value) VALUES (?, ?, ?, ?)').run(uuidv4(), log.id, 'D', 11);
db.prepare('INSERT INTO drying_baselines (id, log_id, material_code, baseline_value) VALUES (?, ?, ?, ?)').run(uuidv4(), log.id, 'CW', 8);

// 5. Create visit
const visitId = uuidv4();
db.prepare('INSERT INTO drying_visits (id, log_id, visit_number) VALUES (?, ?, ?)').run(visitId, log.id, 1);

// 6. Save atmospheric readings (GPP auto-calculated)
dryingLogs.saveAtmosphericReadings(visitId, [
  { readingType: 'chamber_intake', chamberId: chamberId, dehuNumber: null, tempF: 75, rhPercent: 60 },
  { readingType: 'outside', chamberId: null, dehuNumber: null, tempF: 80, rhPercent: 50 }
]);
const atmo = dryingLogs.getAtmosphericByVisit(visitId);
console.log('Atmospheric GPP auto-calc:', atmo[0].gpp === 77.8 ? 'PASS' : 'FAIL', atmo[0].gpp);

// 7. Save moisture readings (dry standard auto-computed)
dryingLogs.saveMoistureReadings(visitId, [
  { refPointId: rp1.id, readingValue: 15 },
  { refPointId: rp2.id, readingValue: 10 }
], log.id);
const moisture = dryingLogs.getMoistureByVisit(visitId);
const drywallReading = moisture.find(m => m.ref_point_id === rp1.id);
const cwReading = moisture.find(m => m.ref_point_id === rp2.id);
console.log('Drywall dry standard (15 <= 11+4):', drywallReading.meets_dry_standard === 1 ? 'PASS' : 'FAIL');
console.log('CW dry standard (10 <= 8+4):', cwReading.meets_dry_standard === 1 ? 'PASS' : 'FAIL');

// Cleanup
db.prepare('DELETE FROM apex_jobs WHERE id = ?').run(jobId);
console.log('Integration test complete');
"
```
Expected: All PASS. GPP auto-calculated as 77.8, dry standard correctly computed, ref point numbering sequential.
  </verify>
  <done>
- calculateGPP produces correct values for all 15 validation pairs
- GPP is auto-computed and stored when saving atmospheric readings
- meetsDryStandard uses <= comparison (baseline + 4 inclusive)
- Moisture readings auto-compute meets_dry_standard from baseline lookup
- Reference point numbering is atomic (transaction-wrapped increment)
- All CRUD functions exported and working
  </done>
</task>

</tasks>

<verification>
1. GPP validation: All 15 reference pairs match within +/- 0.1 GPP
2. GPP edge cases: null/NaN/out-of-range inputs return null
3. Default pressure: calculateGPP(75, 60) with no 3rd arg uses 14.696 psia
4. Dry standard: 15 <= 11+4 = true, 16 <= 11+4 = false
5. Atomic ref numbering: Two sequential addRefPoint calls produce ref_numbers 1 and 2
6. Atmospheric save: GPP is computed and stored in the row
7. Moisture save: meets_dry_standard is computed from baseline lookup and stored
8. Transaction safety: Bulk saves are atomic (all-or-nothing)
</verification>

<success_criteria>
- calculateGPP matches all 15 IICRC reference pairs within +/- 0.1
- calculateGPP uses sea level 14.696 psia by default, rounds to 1 decimal
- meetsDryStandard uses <= (not <) for the +4 comparison
- Saving atmospheric readings auto-computes GPP from temp/RH
- Saving moisture readings auto-computes meets_dry_standard from baseline
- addRefPoint atomically increments next_ref_number within a transaction
- All CRUD functions are exported and callable by Phase 2 API routes
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-gpp-engine/01-02-SUMMARY.md`
</output>
