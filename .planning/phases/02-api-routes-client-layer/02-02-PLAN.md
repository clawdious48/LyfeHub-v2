---
phase: 02-api-routes-client-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/js/api.js
autonomous: true

must_haves:
  truths:
    - "api.request() correctly sends FormData bodies without setting Content-Type or JSON-stringifying (browser sets multipart boundary automatically)"
    - "api.request() still works identically for all existing JSON body requests (no regression)"
    - "Frontend api object exposes methods for every drying endpoint: log CRUD, chamber CRUD, room CRUD, ref point CRUD, baseline upsert, visit CRUD, bulk save, notes, photo upload"
    - "Photo upload method constructs FormData with file inputs and sends via api.request()"
  artifacts:
    - path: "frontend/js/api.js"
      provides: "FormData-safe request() method + all drying endpoint methods"
      contains: "instanceof FormData"
  key_links:
    - from: "frontend/js/api.js"
      to: "/api/apex-jobs/:jobId/drying/*"
      via: "this.request() calls to drying endpoints"
      pattern: "drying/"
    - from: "api.request()"
      to: "FormData detection"
      via: "instanceof FormData check before body processing"
      pattern: "instanceof FormData"
---

<objective>
Fix the `api.request()` method to correctly handle FormData uploads (DB-03), and add all drying endpoint methods to `frontend/js/api.js` (DB-04).

Purpose: The existing `api.request()` unconditionally sets `Content-Type: application/json` and JSON-stringifies all object bodies, which breaks multipart/form-data uploads. The fix is a prerequisite for photo uploads. The drying API methods give the frontend a clean interface to every backend drying endpoint.

Output: Updated `frontend/js/api.js` with FormData-safe request handling and ~15 new drying methods.
</objective>

<execution_context>
@C:/Users/jaker/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jaker/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-routes-client-layer/02-RESEARCH.md
@frontend/js/api.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix api.request() FormData handling for multipart uploads</name>
  <files>frontend/js/api.js</files>
  <action>
Modify the `request()` method in `frontend/js/api.js` to detect FormData bodies and handle them differently from JSON bodies.

**Current code (lines 12-27):**
```javascript
async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;

    const config = {
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers,
        },
        credentials: 'include',
    };

    if (options.body && typeof options.body === 'object') {
        config.body = JSON.stringify(options.body);
    }
```

**Replace with:**
```javascript
async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;

    const config = {
        ...options,
        credentials: 'include',
    };

    if (options.body instanceof FormData) {
        // FormData: let browser set Content-Type with multipart boundary
        config.body = options.body;
        config.headers = { ...options.headers };
    } else {
        // JSON: set Content-Type and stringify object bodies
        config.headers = {
            'Content-Type': 'application/json',
            ...options.headers,
        };
        if (options.body && typeof options.body === 'object') {
            config.body = JSON.stringify(options.body);
        }
    }
```

The rest of the `request()` method (fetch call, auth error handling, response parsing) remains UNCHANGED.

**Why this matters:** When body is a FormData instance, the browser must set its own `Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...` header. If we manually set Content-Type to `application/json`, the server receives garbled data with no file content. The `instanceof FormData` check is the standard pattern for this.

**Regression safety:** All existing callers pass plain objects as `body` (e.g., `{ name, email, password }`). These are not FormData instances, so they take the `else` branch -- identical behavior to before.
  </action>
  <verify>
Open `frontend/js/api.js` and confirm:
1. The `instanceof FormData` check exists before the headers/body processing
2. The FormData branch does NOT set Content-Type
3. The JSON branch still sets `Content-Type: application/json` and calls `JSON.stringify`
4. `credentials: 'include'` is present in both branches
  </verify>
  <done>api.request() detects FormData bodies and passes them through without Content-Type override or JSON stringification; all existing JSON-body callers are unaffected.</done>
</task>

<task type="auto">
  <name>Task 2: Add all drying endpoint methods to api.js</name>
  <files>frontend/js/api.js</files>
  <action>
Add a new section to the `api` object in `frontend/js/api.js`, placed AFTER the existing "APEX JOB DETAIL" section and BEFORE the closing `};` of the api object. Follow the exact same JSDoc comment style used throughout the file.

**Add this section:**

```javascript
// ========================================
// DRYING LOGS
// ========================================

/**
 * Drying: Get drying log for a job
 */
async getDryingLog(jobId) {
    return this.request(`/apex-jobs/${jobId}/drying/log`);
},

/**
 * Drying: Create drying log for a job
 */
async createDryingLog(jobId) {
    return this.request(`/apex-jobs/${jobId}/drying/log`, {
        method: 'POST',
    });
},

/**
 * Drying: Get all chambers for a job's drying log
 */
async getDryingChambers(jobId) {
    return this.request(`/apex-jobs/${jobId}/drying/chambers`);
},

/**
 * Drying: Create a chamber
 */
async createDryingChamber(jobId, data) {
    return this.request(`/apex-jobs/${jobId}/drying/chambers`, {
        method: 'POST',
        body: data,
    });
},

/**
 * Drying: Update a chamber
 */
async updateDryingChamber(jobId, chamberId, data) {
    return this.request(`/apex-jobs/${jobId}/drying/chambers/${chamberId}`, {
        method: 'PATCH',
        body: data,
    });
},

/**
 * Drying: Delete a chamber
 */
async deleteDryingChamber(jobId, chamberId) {
    return this.request(`/apex-jobs/${jobId}/drying/chambers/${chamberId}`, {
        method: 'DELETE',
    });
},

/**
 * Drying: Get all rooms for a job's drying log
 * @param {string} chamberId - Optional chamber ID to filter by
 */
async getDryingRooms(jobId, chamberId = null) {
    const query = chamberId ? `?chamberId=${chamberId}` : '';
    return this.request(`/apex-jobs/${jobId}/drying/rooms${query}`);
},

/**
 * Drying: Create a room
 */
async createDryingRoom(jobId, data) {
    return this.request(`/apex-jobs/${jobId}/drying/rooms`, {
        method: 'POST',
        body: data,
    });
},

/**
 * Drying: Update a room
 */
async updateDryingRoom(jobId, roomId, data) {
    return this.request(`/apex-jobs/${jobId}/drying/rooms/${roomId}`, {
        method: 'PATCH',
        body: data,
    });
},

/**
 * Drying: Delete a room
 */
async deleteDryingRoom(jobId, roomId) {
    return this.request(`/apex-jobs/${jobId}/drying/rooms/${roomId}`, {
        method: 'DELETE',
    });
},

/**
 * Drying: Get all reference points for a job's drying log
 */
async getDryingRefPoints(jobId) {
    return this.request(`/apex-jobs/${jobId}/drying/ref-points`);
},

/**
 * Drying: Add a reference point (server auto-assigns ref_number)
 */
async createDryingRefPoint(jobId, data) {
    return this.request(`/apex-jobs/${jobId}/drying/ref-points`, {
        method: 'POST',
        body: data,
    });
},

/**
 * Drying: Update a reference point
 */
async updateDryingRefPoint(jobId, rpId, data) {
    return this.request(`/apex-jobs/${jobId}/drying/ref-points/${rpId}`, {
        method: 'PATCH',
        body: data,
    });
},

/**
 * Drying: Demolish a reference point
 */
async demolishDryingRefPoint(jobId, rpId, visitId) {
    return this.request(`/apex-jobs/${jobId}/drying/ref-points/${rpId}/demolish`, {
        method: 'POST',
        body: { visitId },
    });
},

/**
 * Drying: Get all baselines for a job's drying log
 */
async getDryingBaselines(jobId) {
    return this.request(`/apex-jobs/${jobId}/drying/baselines`);
},

/**
 * Drying: Upsert a baseline (create or update by material_code)
 */
async upsertDryingBaseline(jobId, data) {
    return this.request(`/apex-jobs/${jobId}/drying/baselines`, {
        method: 'PUT',
        body: data,
    });
},

/**
 * Drying: Get all visits for a job's drying log
 */
async getDryingVisits(jobId) {
    return this.request(`/apex-jobs/${jobId}/drying/visits`);
},

/**
 * Drying: Create a new visit (server auto-assigns visit_number)
 */
async createDryingVisit(jobId, data = {}) {
    return this.request(`/apex-jobs/${jobId}/drying/visits`, {
        method: 'POST',
        body: data,
    });
},

/**
 * Drying: Get a visit with all child data (atmospheric, moisture, equipment, notes)
 */
async getDryingVisit(jobId, visitId) {
    return this.request(`/apex-jobs/${jobId}/drying/visits/${visitId}`);
},

/**
 * Drying: Bulk save visit data (atmospheric + moisture + equipment in one transaction)
 * @param {object} data - { atmospheric: [...], moisture: [...], equipment: [...] }
 */
async saveDryingVisit(jobId, visitId, data) {
    return this.request(`/apex-jobs/${jobId}/drying/visits/${visitId}/save`, {
        method: 'POST',
        body: data,
    });
},

/**
 * Drying: Delete a visit
 */
async deleteDryingVisit(jobId, visitId) {
    return this.request(`/apex-jobs/${jobId}/drying/visits/${visitId}`, {
        method: 'DELETE',
    });
},

/**
 * Drying: Get notes for a visit
 */
async getDryingVisitNotes(jobId, visitId) {
    return this.request(`/apex-jobs/${jobId}/drying/visits/${visitId}/notes`);
},

/**
 * Drying: Add a note to a visit
 */
async createDryingVisitNote(jobId, visitId, data) {
    return this.request(`/apex-jobs/${jobId}/drying/visits/${visitId}/notes`, {
        method: 'POST',
        body: data,
    });
},

/**
 * Drying: Delete a visit note
 */
async deleteDryingVisitNote(jobId, visitId, noteId) {
    return this.request(`/apex-jobs/${jobId}/drying/visits/${visitId}/notes/${noteId}`, {
        method: 'DELETE',
    });
},

/**
 * Drying: Upload photos (processed server-side with sharp)
 * @param {string} jobId - Job ID
 * @param {FileList|File[]} files - Files to upload
 */
async uploadDryingPhotos(jobId, files) {
    const formData = new FormData();
    for (const file of files) {
        formData.append('photos', file);
    }
    return this.request(`/apex-jobs/${jobId}/drying/photos`, {
        method: 'POST',
        body: formData,
    });
},
```

**Method count:** 25 methods covering every endpoint in the drying API.

**Naming convention:** All drying methods are prefixed with `getDrying`, `createDrying`, `updateDrying`, `deleteDrying`, `saveDrying`, or `uploadDrying` -- consistent with existing patterns like `getApexJob`, `createApexJob`, etc.

**The `uploadDryingPhotos` method** is the key one that exercises the FormData fix from Task 1. It creates a FormData object, appends all files, and passes it as the body. The `instanceof FormData` check in `request()` ensures the browser handles Content-Type.
  </action>
  <verify>
Open `frontend/js/api.js` and confirm:
1. The "DRYING LOGS" section exists after "APEX JOB DETAIL"
2. Count ~25 async methods starting with `getDrying`, `createDrying`, `updateDrying`, `deleteDrying`, `saveDrying`, `uploadDrying`, `upsertDrying`, `demolishDrying`
3. `uploadDryingPhotos` creates a `FormData` and passes it as `body`
4. All methods use `this.request()` with correct endpoint paths starting with `/apex-jobs/${jobId}/drying/`
5. The file still ends with `window.api = api;`
  </verify>
  <done>frontend/js/api.js has 25 drying endpoint methods covering every REST operation, plus the uploadDryingPhotos method that uses FormData for multipart upload.</done>
</task>

</tasks>

<verification>
After both tasks are complete:
1. Confirm `instanceof FormData` check exists in `api.request()` method
2. Count drying methods: search for `async.*Drying` in api.js, expect ~25 matches
3. Confirm `uploadDryingPhotos` creates FormData and appends files
4. Confirm file ends with `window.api = api;` (syntax valid, no trailing comma issues)
</verification>

<success_criteria>
- api.request() detects FormData via instanceof and skips Content-Type / JSON.stringify (DB-03)
- api.request() still works for all existing JSON body requests (no regression)
- 25 drying endpoint methods exist in api.js covering: log (2), chambers (4), rooms (4), ref points (4), baselines (2), visits (5), notes (3), photos (1) (DB-04)
- uploadDryingPhotos constructs FormData from file inputs
- All methods follow existing naming conventions and JSDoc style
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-routes-client-layer/02-02-SUMMARY.md`
</output>
